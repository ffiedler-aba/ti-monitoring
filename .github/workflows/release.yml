name: Release Pipeline

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version (z.B. 1.2.3)'
        required: true
        type: string
      prerelease:
        description: 'Als Pre-Release erstellen'
        required: false
        type: boolean
        default: true

env:
  PYTHON_VERSION: '3.12'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Run Tests
      run: |
        # Hier k√∂nnen Tests hinzugef√ºgt werden
        echo "Tests w√ºrden hier laufen"
        
  build-portable:
    needs: test
    runs-on: windows-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Create Portable Build
      run: |
        # Erstelle portable-build Verzeichnis
        $StageDir = "portable-build"
        if (Test-Path $StageDir) { Remove-Item $StageDir -Recurse -Force }
        New-Item -ItemType Directory -Path $StageDir | Out-Null
        
        # Kopiere Repository-Inhalt (ohne .git, node_modules, etc.)
        $excludeDirs = @('.git','node_modules','.venv','portable-build','dist','build','out','.mypy_cache','.pytest_cache','.ruff_cache','__pycache__')
        $excludeFiles = @('.DS_Store')
        
        $src = (Get-Location).Path
        $dst = (Resolve-Path -LiteralPath $StageDir).Path
        
        $excludeDirsArgs = @()
        foreach ($d in $excludeDirs) { $excludeDirsArgs += @('/XD', (Join-Path $src $d)) }
        $excludeFilesArgs = @()
        foreach ($f in $excludeFiles) { $excludeFilesArgs += @('/XF', (Join-Path $src $f)) }
        
        $args = @($src, $dst, '/E') + $excludeDirsArgs + $excludeFilesArgs
        $rc = Start-Process -FilePath robocopy -ArgumentList $args -NoNewWindow -PassThru -Wait
        if ($rc.ExitCode -gt 7) { throw "Robocopy fehlgeschlagen (ExitCode=$($rc.ExitCode))" }
        
        # Beispielkonfigurationen √ºbernehmen
        Push-Location -LiteralPath $StageDir
        try {
          if ((Test-Path 'config.yaml.example' -PathType Leaf) -and -not (Test-Path 'config.yaml')) {
              Copy-Item 'config.yaml.example' 'config.yaml'
          }
          if ((Test-Path 'notifications.json.example' -PathType Leaf) -and -not (Test-Path 'notifications.json')) {
              Copy-Item 'notifications.json.example' 'notifications.json'
          }
        }
        finally { Pop-Location }
        
        # data/ Verzeichnis sicherstellen
        $dataStage = Join-Path $StageDir 'data'
        if (-not (Test-Path -LiteralPath $dataStage)) {
            New-Item -ItemType Directory -Path $dataStage | Out-Null
        }
        if (Test-Path -LiteralPath 'data' -PathType Container) {
            $rc = Start-Process -FilePath robocopy -ArgumentList @('data', $dataStage, '/E') -NoNewWindow -PassThru -Wait
            if ($rc.ExitCode -gt 7) { throw "Robocopy (data) fehlgeschlagen (ExitCode=$($rc.ExitCode))" }
        }
        
        # tools/ Verzeichnis sicherstellen
        $toolsStage = Join-Path $StageDir 'tools'
        if (-not (Test-Path -LiteralPath $toolsStage)) {
            New-Item -ItemType Directory -Path $toolsStage | Out-Null
        }
        if (Test-Path -LiteralPath 'tools' -PathType Container) {
            $rc = Start-Process -FilePath robocopy -ArgumentList @('tools', $toolsStage, '/E') -NoNewWindow -PassThru -Wait
            if ($rc.ExitCode -gt 7) { throw "Robocopy (tools) fehlgeschlagen (ExitCode=$($rc.ExitCode))" }
        }
        
        # venv erstellen und Requirements installieren
        $venvPath = Join-Path $StageDir '.venv'
        
        # L√∂sche alte venv falls vorhanden
        if (Test-Path -LiteralPath $venvPath) {
            Remove-Item -LiteralPath $venvPath -Recurse -Force
        }
        
        # Erstelle neue venv mit relativen Pfaden
        Write-Host "Erstelle portable venv..."
        Write-Host "Staging-Verzeichnis: $StageDir"
        Write-Host "Venv-Pfad: $venvPath"
        
        # Wechsle ins Staging-Verzeichnis
        Push-Location -LiteralPath $StageDir
        try {
            Write-Host "Aktuelles Verzeichnis: $(Get-Location)"
            
            # Verwende python -m venv mit --copies um relative Pfade zu erzwingen
            Write-Host "Erstelle venv mit --copies Flag..."
            python -m venv .venv --copies
            
            # Pr√ºfe ob venv erstellt wurde
            if (-not (Test-Path -LiteralPath '.venv')) {
                throw "Venv-Verzeichnis wurde nicht erstellt"
            }
            
            $pip = Join-Path '.venv' 'Scripts\python.exe'
            Write-Host "Pip-Pfad: $pip"
            if (-not (Test-Path -LiteralPath $pip)) { 
                Write-Host "Verf√ºgbare Dateien in .venv:"
                Get-ChildItem -LiteralPath '.venv' -Recurse | Select-Object FullName
                throw "Venv wurde nicht korrekt erstellt: $pip"
            }
            
            # Repariere pyvenv.cfg f√ºr portable Verwendung
            $pyvenvCfg = Join-Path '.venv' 'pyvenv.cfg'
            if (Test-Path -LiteralPath $pyvenvCfg) {
                $pyvenvContent = "home = .`ninclude-system-site-packages = false`nversion = 3.12.10`nexecutable = .\Scripts\python.exe`ncommand = .\Scripts\python.exe -m venv ."
                $pyvenvContent | Out-File -FilePath $pyvenvCfg -Encoding UTF8
                Write-Host "pyvenv.cfg f√ºr portable Verwendung konfiguriert"
            }
            
            if (Test-Path -LiteralPath 'requirements.txt' -PathType Leaf) {
                Write-Host "Installiere Requirements in venv"
                & $pip -m pip install --upgrade pip
                & $pip -m pip install -r 'requirements.txt' --no-cache-dir
                Write-Host "Requirements-Installation abgeschlossen"
            } else {
                Write-Host "requirements.txt nicht gefunden, √ºberspringe Installation"
            }
        }
        finally {
            Pop-Location
        }
        
        # ZIP erstellen
        $timestamp = Get-Date -Format 'yyyyMMdd-HHmmss'
        $zipName = "ti-monitoring-portable-$timestamp.zip"
        $zipPath = Join-Path (Get-Location) $zipName
        Write-Host "Erzeuge ZIP: $zipPath"
        if (Test-Path -LiteralPath $zipPath) { Remove-Item -LiteralPath $zipPath -Force }
        Compress-Archive -Path $StageDir -DestinationPath $zipPath -Force
        
    - name: Upload Portable Build
      uses: actions/upload-artifact@v4
      with:
        name: ti-monitoring-portable-${{ github.ref_name }}
        path: ti-monitoring-portable-*.zip
        retention-days: 30
        
    - name: Create GitHub Release
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        files: ti-monitoring-portable-*.zip
        prerelease: ${{ github.event.inputs.prerelease == 'true' || contains(github.ref, 'alpha') || contains(github.ref, 'beta') || contains(github.ref, 'rc') }}
        generate_release_notes: true
        body: |
          ## TI-Monitoring Portable ${{ github.ref_name }}
          
          ### üöÄ Windows Portable Build
          - ‚úÖ Vollst√§ndig portable Windows-Anwendung
          - ‚úÖ Automatische Service-Installation mit NSSM
          - ‚úÖ Virtuelle Python-Umgebung enthalten
          - ‚úÖ Umfassende Installationsanleitung
          
          ### üì¶ Installation
          1. ZIP-Datei entpacken
          2. `install-service.cmd` als Administrator ausf√ºhren
          3. Web-Interface unter http://localhost:8050 aufrufen
          
          ### ‚ú® Features
          - üîç Automatische TI-Service-√úberwachung
          - üåê Web-basierte Benutzeroberfl√§che
          - üìß Universelle Benachrichtigungsoptionen via Apprise
          - üìä Detaillierte Statistiken und Logs
          
          ### üìã Systemanforderungen
          - Windows 10/11 (64-bit)
          - Administratorrechte f√ºr Service-Installation
          - Internetverbindung f√ºr API-Updates
          
          ### üîß Support
          Bei Problemen siehe: [Installationsanleitung](docs/INSTALL_Windows_Portable.md)
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
  notify:
    needs: [test, build-portable]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Notify Success
      if: needs.build-portable.result == 'success'
      run: |
        echo "‚úÖ Release erfolgreich erstellt: ${{ github.ref_name }}"
        
    - name: Notify Failure
      if: needs.build-portable.result == 'failure'
      run: |
        echo "‚ùå Release fehlgeschlagen: ${{ github.ref_name }}"
