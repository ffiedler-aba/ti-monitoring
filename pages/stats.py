import dash
from dash import html, dcc
from dash import dash_table
from dash import Input, Output, callback, no_update, State
from mylibrary import *
import yaml
import os
import time
import gc
import json
import pandas as pd
import pytz

# Configuration cache for stats page with size limit
_stats_config_cache = {}
_stats_config_cache_timestamp = 0
_stats_config_cache_ttl = 300  # 5 seconds cache TTL
_stats_config_cache_max_size = 10  # Limit cache size



def load_config():
    """Load configuration from YAML file with caching"""
    global _stats_config_cache, _stats_config_cache_timestamp

    current_time = time.time()
    if (not _stats_config_cache or
        current_time - _stats_config_cache_timestamp > _stats_config_cache_ttl):

        config_path = os.path.join(os.path.dirname(__file__), '..', 'config.yaml')
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                _stats_config_cache = yaml.safe_load(f) or {}
            _stats_config_cache_timestamp = current_time

            # Limit cache size
            if len(_stats_config_cache) > _stats_config_cache_max_size:
                # Keep only the most recent entries
                keys = list(_stats_config_cache.keys())[:_stats_config_cache_max_size]
                _stats_config_cache = {k: _stats_config_cache[k] for k in keys}
        except (FileNotFoundError, Exception):
            _stats_config_cache = {}
            _stats_config_cache_timestamp = current_time

    return _stats_config_cache

def load_core_config():
    """Load core configuration from cached config"""
    config = load_config()
    return config.get('core', {})

# Cache for CI metadata loaded from TimescaleDB
_ci_meta_cache = None
_ci_meta_cache_timestamp = 0
_ci_meta_cache_ttl = 300  # 5 minutes cache TTL

def load_ci_metadata_map():
    """Load CI -> {name, organization, product} map from TimescaleDB with caching."""
    global _ci_meta_cache, _ci_meta_cache_timestamp

    current_time = time.time()
    if (_ci_meta_cache is not None and
        current_time - _ci_meta_cache_timestamp < _ci_meta_cache_ttl):
        return _ci_meta_cache

    try:
        # Get CI metadata directly from TimescaleDB
        with get_db_conn() as conn:
            query = """
            SELECT ci, name, organization, product
            FROM ci_metadata
            ORDER BY ci
            """
            with conn.cursor() as cur:
                cur.execute(query)
                results = cur.fetchall()

        # Create mapping
        mapping = {}
        for row in results:
            ci, name, organization, product = row
            mapping[str(ci)] = {
                'name': name or '',
                'organization': organization or '',
                'product': product or ''
            }

        _ci_meta_cache = mapping
        _ci_meta_cache_timestamp = current_time
        return mapping

    except Exception as e:
        print(f"Error loading CI metadata from TimescaleDB: {e}")
        return _ci_meta_cache or {}

def get_cached_statistics(config_file_name, cis):
    """Get statistics from JSON file (generated by cron.py) or calculate them if file doesn't exist"""

    # Try to load statistics from JSON file first
    statistics_file_path = os.path.join(os.path.dirname(__file__), '..', 'data', 'statistics.json')

    try:
        if os.path.exists(statistics_file_path):
            with open(statistics_file_path, 'r', encoding='utf-8') as f:
                file_stats = json.load(f)

            # Check if the file has valid statistics
            if file_stats and 'calculated_at' in file_stats:
                file_age = time.time() - file_stats['calculated_at']
                print(f"Using statistics from file (age: {file_age:.1f}s)")

                # Convert timestamp strings back to datetime objects for display
                if file_stats.get('latest_timestamp'):
                    file_stats['latest_timestamp'] = pd.to_datetime(file_stats['latest_timestamp'])
                if file_stats.get('earliest_timestamp'):
                    file_stats['earliest_timestamp'] = pd.to_datetime(file_stats['earliest_timestamp'])

                # Convert product_counts and organization_counts back to pandas Series
                if file_stats.get('product_counts'):
                    file_stats['product_counts'] = pd.Series(file_stats['product_counts'])
                if file_stats.get('organization_counts'):
                    file_stats['organization_counts'] = pd.Series(file_stats['organization_counts'])

                # Ensure overall_availability_percentage_total exists (fallback to overall_availability_percentage)
                if 'overall_availability_percentage_total' not in file_stats:
                    file_stats['overall_availability_percentage_total'] = file_stats.get('overall_availability_percentage', 0)

                # Recalculate data age dynamically based on current time
                if file_stats.get('latest_timestamp'):
                    current_time = pd.Timestamp.now(tz=pytz.timezone('Europe/Berlin'))
                    data_age_hours = (current_time - file_stats['latest_timestamp']).total_seconds() / 3600
                    file_stats['data_age_formatted'] = format_duration(data_age_hours)

                # Ensure top_unstable_cis_by_incidents exists (map from top_unstable_cis)
                if 'top_unstable_cis_by_incidents' not in file_stats and 'top_unstable_cis' in file_stats:
                    file_stats['top_unstable_cis_by_incidents'] = file_stats['top_unstable_cis']

                # Debug: Print key statistics to verify they are loaded correctly
                print(f"DEBUG: Loaded statistics - uptime: {file_stats.get('overall_uptime_minutes', 'NOT_FOUND')}, downtime: {file_stats.get('overall_downtime_minutes', 'NOT_FOUND')}, mttr: {file_stats.get('mttr_minutes_mean', 'NOT_FOUND')}")
                print(f"DEBUG: Loaded CI data - count: {len(file_stats.get('top_unstable_cis_by_incidents', []))}")

                return file_stats
    except Exception as e:
        print(f"Error loading statistics from file: {e}")

    # Fallback: calculate statistics if file doesn't exist or is invalid
    print("Statistics file not available, calculating new statistics")

    # Check if TimescaleDB is enabled
    config = load_config()
    use_timescaledb = config.get('core', {}).get('timescaledb', {}).get('enabled', False)

    if use_timescaledb:
        print("Using TimescaleDB for statistics calculation...")
        # Import the TimescaleDB statistics function from mylibrary
        try:
            import mylibrary
            new_stats = mylibrary.get_timescaledb_statistics_data()
            if new_stats:
                return new_stats
        except Exception as e:
            print(f"Error calculating TimescaleDB statistics: {e}")

    # Final fallback: use HDF5-based calculation
    new_stats = calculate_overall_statistics(config_file_name, cis)
    return new_stats



def format_duration(hours):
    """Format duration in a human-readable way"""
    if hours < 1:
        minutes = int(hours * 60)
        return f"{minutes} Minuten"
    elif hours < 24:
        return f"{hours:.1f} Stunden"
    else:
        days = hours / 24
        return f"{days:.1f} Tage"

def truncate_organization(org_name, max_length=40):
    """Truncate organization name if too long"""
    if not org_name:
        return ""
    if len(org_name) <= max_length:
        return org_name
    return org_name[:max_length-3] + "..."

def calculate_overall_statistics(config_file_name, cis):
    """
    Calculate overall statistics for all Configuration Items including:
    - Total counts and current availability
    - Overall availability percentage
    - Recording time range
    - Product distribution
    - Organization distribution
    """
    if cis.empty:
        return {}

    # Basic counts
    total_cis = len(cis)
    currently_available = cis['current_availability'].sum()
    currently_unavailable = total_cis - currently_available
    overall_availability_percentage = (currently_available / total_cis) * 100 if total_cis > 0 else 0

    # Product distribution
    product_counts = cis['product'].value_counts()
    total_products = len(product_counts)

    # Organization distribution
    organization_counts = cis['organization'].value_counts()
    total_organizations = len(organization_counts)

    # Current status distribution
    status_counts = cis['current_availability'].value_counts()
    available_count = status_counts.get(1, 0)
    unavailable_count = status_counts.get(0, 0)

    # Recent changes (availability_difference != 0)
    recent_changes = cis[cis['availability_difference'] != 0]
    changes_count = len(recent_changes)

    # Get overall recording time range (from the most recent timestamp)
    latest_timestamp = None
    earliest_timestamp = None
    data_age_formatted = "Unbekannt"
    total_recording_minutes = 0

    # Try to get timestamps from availability data (where the real time series data is stored)
    try:
        import h5py
        if os.path.exists(config_file_name):
            with h5py.File(config_file_name, 'r', swmr=True) as f:
                if 'availability' in f:
                    availability_group = f['availability']
                    all_timestamps = []

                    # Collect all timestamps from all CIs
                    for ci_name in availability_group.keys():
                        ci_group = availability_group[ci_name]
                        for timestamp_str in ci_group.keys():
                            try:
                                timestamp = pd.to_datetime(float(timestamp_str), unit='s').tz_localize('UTC').tz_convert('Europe/Berlin')
                                all_timestamps.append(timestamp)
                            except:
                                continue

                    print(f"Collected {len(all_timestamps)} timestamps from {len(availability_group.keys())} CIs")

                    if all_timestamps:
                        earliest_timestamp = min(all_timestamps)
                        latest_timestamp = max(all_timestamps)

                        # Get current time in Europe/Berlin
                        current_time = pd.Timestamp.now(tz=pytz.timezone('Europe/Berlin'))
                        data_age_hours = (current_time - latest_timestamp).total_seconds() / 3600
                        data_age_formatted = format_duration(data_age_hours)

                        # Calculate total recording time from the overall time range
                        total_recording_minutes = (latest_timestamp - earliest_timestamp).total_seconds() / 60
                        print(f"Total recording time from availability data: {earliest_timestamp} to {latest_timestamp} = {total_recording_minutes:.1f} minutes ({total_recording_minutes/60/24:.1f} days)")
                        # Also log to stderr for debugging
                        import sys
                        print(f"DEBUG: Total recording time: {total_recording_minutes:.1f} minutes", file=sys.stderr)
                    else:
                        print("No timestamps found in availability data")
    except Exception as e:
        print(f"Error reading availability timestamps: {e}")

    # Fallback: Try to get timestamps from different possible columns in general data
    if total_recording_minutes == 0:
        timestamp_columns = ['time', 'timestamp', 'created_at', 'updated_at']
        for col in timestamp_columns:
            if col in cis.columns and not cis[col].isna().all():
                try:
                    latest_timestamp = pd.to_datetime(cis[col].max())
                    earliest_timestamp = pd.to_datetime(cis[col].min())

                    # Ensure both timestamps have timezone info and are in Europe/Berlin
                    if latest_timestamp.tz is None:
                        latest_timestamp = latest_timestamp.tz_localize('Europe/Berlin')
                    elif latest_timestamp.tz != pytz.timezone('Europe/Berlin'):
                        latest_timestamp = latest_timestamp.tz_convert('Europe/Berlin')

                    if earliest_timestamp.tz is None:
                        earliest_timestamp = earliest_timestamp.tz_localize('Europe/Berlin')
                    elif earliest_timestamp.tz != pytz.timezone('Europe/Berlin'):
                        earliest_timestamp = earliest_timestamp.tz_convert('Europe/Berlin')

                    # Get current time in Europe/Berlin
                    current_time = pd.Timestamp.now(tz=pytz.timezone('Europe/Berlin'))
                    data_age_hours = (current_time - latest_timestamp).total_seconds() / 3600
                    data_age_formatted = format_duration(data_age_hours)

                    # Calculate total recording time from the overall time range
                    total_recording_minutes = (latest_timestamp - earliest_timestamp).total_seconds() / 60
                    print(f"Total recording time from general data: {earliest_timestamp} to {latest_timestamp} = {total_recording_minutes:.1f} minutes")
                    break
                except Exception as e:
                    print(f"Error processing timestamp column {col}: {e}")
                    continue

    # If no timestamp columns found or all timestamps are the same, try to get from data file metadata
    if total_recording_minutes == 0:
        try:
            # No fallback needed - TimescaleDB only
            pass
        except Exception as e:
            print(f"Error in statistics calculation: {e}")

    return {
        'total_cis': total_cis,
        'currently_available': currently_available,
        'currently_unavailable': currently_unavailable,
        'overall_availability_percentage': overall_availability_percentage,
        'overall_availability_percentage_total': overall_availability_percentage,  # Same as current availability for now
        'total_products': total_products,
        'total_organizations': total_organizations,
        'available_count': available_count,
        'unavailable_count': unavailable_count,
        'changes_count': changes_count,
        'latest_timestamp': latest_timestamp,
        'earliest_timestamp': earliest_timestamp,
        'data_age_formatted': data_age_formatted,
        'product_counts': product_counts,
        'organization_counts': organization_counts,
        'total_recording_minutes': total_recording_minutes
    }

dash.register_page(__name__, path='/stats')

def create_overall_statistics_display(stats):
    """Create the overall statistics display section"""
    children = [
        html.H3('üìä Gesamtstatistik aller Configuration Items'),

        # Main overview
        html.Div(className='stats-overview', children=[
            html.Div(className='stat-card', children=[
                html.H4('üéØ √úbersicht'),
                html.Div(className='stat-grid', children=[
                    html.Div(className='stat-item', children=[
                        html.Strong('Gesamtanzahl CIs: '),
                        html.Span(f'{stats["total_cis"]:,}')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Aktuell verf√ºgbar: '),
                        html.Span(f'{stats["currently_available"]:,}')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Aktuell nicht verf√ºgbar: '),
                        html.Span(f'{stats["currently_unavailable"]:,}')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Gesamtverf√ºgbarkeit (Zeitbasis): ', title='Zeitgewichtete Verf√ºgbarkeit √ºber alle CIs im √ºberwachten Zeitraum'),
                        html.Span(
                            f"{(stats.get('overall_availability_percentage_rollup') or 0):.2f}%",
                            title='Zeitgewichtete Verf√ºgbarkeit √ºber alle CIs im √ºberwachten Zeitraum'
                        )
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Gesamtdauer Aufzeichnung: '),
                        html.Span(format_duration(stats["total_recording_minutes"] / 60) if stats.get("total_recording_minutes", 0) > 0 else 'Unbekannt')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Kumulative Uptime (√ºber alle CIs): ', title='Summe der Betriebszeiten aller CIs im Zeitraum'),
                        html.Span(
                            format_duration((stats.get('overall_uptime_minutes') or 0) / 60),
                            title='Summe der Betriebszeiten aller CIs im Zeitraum'
                        )
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('√ò Uptime pro CI im Zeitraum: ', title='Durchschnittliche Betriebszeit je CI im Zeitraum'),
                        html.Span(
                            format_duration(
                                (
                                    ((stats.get('overall_uptime_minutes') or 0) / max(1, int(stats.get('total_cis', 0))))
                                ) / 60
                            ),
                            title='Durchschnittliche Betriebszeit je CI im Zeitraum'
                        )
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Gesamte Downtime: '),
                        html.Span(format_duration((stats.get('overall_downtime_minutes') or 0) / 60))
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Incidents (gesamt): ', title='Anzahl Ausf√§lle (√úberg√§nge von verf√ºgbar zu nicht verf√ºgbar)'),
                        html.Span(f"{int(stats.get('total_incidents', 0))}", title='Anzahl Ausf√§lle (√úberg√§nge von verf√ºgbar zu nicht verf√ºgbar)')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('MTTR (√ò, Minuten): ', title='Mean Time To Repair ‚Äì durchschnittliche Dauer eines Ausfalls bis zur Wiederherstellung'),
                        html.Span(f"{(stats.get('mttr_minutes_mean') or 0):.1f}", title='Mean Time To Repair ‚Äì durchschnittliche Dauer eines Ausfalls bis zur Wiederherstellung')
                    ]),

                ])
            ]),

            html.Div(className='stat-card', children=[
                html.H4('üìÖ Datenstatus'),
                html.Div(className='stat-grid', children=[
                    html.Div(className='stat-item', children=[
                        html.Strong('Letzte Aktualisierung: '),
                        html.Span(
                            pd.to_datetime(stats.get("last_updated", stats.get("latest_timestamp", ""))).tz_convert('Europe/Berlin').strftime('%d.%m.%Y %H:%M:%S Uhr')
                            if stats.get("last_updated", stats.get("latest_timestamp", "")) else 'Unbekannt'
                        )
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('N√§chste Aktualisierung: '),
                        html.Span(
                            (pd.to_datetime(stats.get("last_updated", stats.get("latest_timestamp", ""))).tz_convert('Europe/Berlin') + pd.Timedelta(hours=1)).strftime('%d.%m.%Y %H:%M:%S Uhr')
                            if stats.get("last_updated", stats.get("latest_timestamp", "")) else 'Unbekannt'
                        )
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Datenalter: '),
                        html.Span(stats.get("data_age_formatted", "Unbekannt"))
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('K√ºrzliche √Ñnderungen: '),
                        html.Span(f'{stats.get("changes_count", 0):,}')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Datenbankgr√∂√üe: '),
                        html.Span(f'{stats.get("database_size_mb", 0):.1f} MB')
                    ]),
                    html.Div(className='stat-item', children=[
                        html.Strong('Gesamtanzahl Datenpunkte: '),
                        html.Span(f"{int(stats.get('total_datapoints', 0)):,}")
                    ])
                ])
            ]),



        ])
    ]

    # Entfernt: doppelte Gesamtstatistik (zeitgewichtete Verf√ºgbarkeit & Aufzeichnungszeit)





    return html.Div(className='overall-statistics box', children=children)

def serve_layout():
    # Load core configurations (now cached)
    core_config = load_core_config()

    # TimescaleDB mode - no file_name needed
    config_file_name = None
    config_url = core_config.get('url')

    # Try to get data from TimescaleDB
    try:
        cis = get_data_of_all_cis_from_timescaledb()
    except Exception as e:
        print(f"Error reading data from TimescaleDB: {e}")
        cis = pd.DataFrame()  # Empty DataFrame

    # Check if DataFrame is empty
    if cis.empty:
        # Try to load data from API if URL is available
        if config_url:
            try:
                print(f"Loading data from API: {config_url}")
                update_file(config_file_name, config_url)
                # Try to read data again
                cis = get_data_of_all_cis(config_file_name)
                print(f"Loaded {len(cis)} records from API")
            except Exception as e:
                print(f"Error loading data from API: {e}")

        # If still empty, show message
        if cis.empty:
            layout = html.Div([
                html.P('Keine Daten verf√ºgbar. Versuche Daten von der API zu laden...'),
                html.P('Falls das Problem weiterhin besteht, √ºberpr√ºfen Sie die API-Verbindung.'),
                html.P(f'API URL: {config_url or "Nicht konfiguriert"}'),
                html.P(f'Daten-Datei: {config_file_name}')
            ])
            return layout

    # Check if 'product' column exists
    if 'product' not in cis.columns:
        layout = html.Div([
            html.P('Daten sind verf√ºgbar, aber die Spalte "product" fehlt. M√∂glicherweise ist die Datenstruktur fehlerhaft.'),
            html.P('Verf√ºgbare Spalten: ' + ', '.join(cis.columns.tolist())),
            html.P(f'Anzahl Datens√§tze: {len(cis)}')
        ])
        return layout

    # Get statistics from cache or calculate them
    overall_stats = get_cached_statistics(config_file_name, cis)
    # Fallback: wenn Liste leer ist, aus statistics.json nachladen
    try:
        statistics_file_path = os.path.join(os.path.dirname(__file__), '..', 'data', 'statistics.json')
        if not overall_stats.get('top_unstable_cis_by_incidents') and os.path.exists(statistics_file_path):
            with open(statistics_file_path, 'r', encoding='utf-8') as f:
                file_stats = json.load(f)
            overall_stats['top_unstable_cis_by_incidents'] = file_stats.get('top_unstable_cis', [])
    except Exception as e:
        print(f"Warning loading statistics.json fallback: {e}")

    # Force garbage collection after loading large datasets
    gc.collect()

    # Additional cleanup for large DataFrames
    if 'cis' in locals():
        del cis
        gc.collect()

    layout = html.Div([
        html.P('Hier finden Sie eine umfassende Gesamtstatistik aller Configuration Items. Neue Daten werden st√ºndlich neu berechnet. Laden Sie die Seite ggfs. neu, um die Ansicht zu aktualisieren.'),

        # Cache information
        html.Div(className='cache-info', children=[
            html.P(f'üìä Statistiken werden st√ºndlich von cron.py berechnet und gecacht'),
            html.P(f'üîÑ N√§chste Aktualisierung: St√ºndlich')
        ]),

        # Overall statistics section
        create_overall_statistics_display(overall_stats),

        # Location component for navigation
        dcc.Location(id='stats-location', refresh=False),

        # Top-Listen (sortable DataTable)
        html.Div(className='overall-statistics box', children=[
            html.Div(className='stat-card', children=[
                html.H4('üö® Top instabile CIs (Incidents)'),
                (lambda rows: dash_table.DataTable(
                    id='unstable-cis-table',
                    data=rows,
                    row_selectable=False,
                    row_deletable=False,
                    columns=[
                        {"name": "Organisation", "id": "organization"},
                        {"name": "Name", "id": "name"},
                        {"name": "Produkt", "id": "product"},
                        {"name": "Incidents", "id": "incidents", "type": "numeric"},
                        {"name": "Downtime (Minuten)", "id": "downtime_minutes", "type": "numeric", "format": {"specifier": ".0f"}},
                        {"name": "Verf√ºgbarkeit (%)", "id": "availability_percentage", "type": "numeric", "format": {"specifier": ".2f"}},
                    ],
                    sort_action='native',
                    sort_mode='multi',
                    style_table={'overflowX': 'auto', 'minWidth': '100%', 'backgroundColor': 'var(--bg-color)', 'color': 'var(--text-color)'},
                    style_cell={'padding': '8px', 'fontSize': '0.95rem', 'backgroundColor': 'var(--bg-color)', 'color': 'var(--text-color)', 'border': '1px solid var(--border-color)'},
                    style_cell_conditional=[
                        {"if": {"column_id": "organization"}, "textAlign": "left", "maxWidth": "120px", "minWidth": "100px", "overflow": "hidden", "textOverflow": "ellipsis"},
                        {"if": {"column_id": "name"}, "textAlign": "left", "maxWidth": "150px", "minWidth": "120px", "overflow": "hidden", "textOverflow": "ellipsis"},
                        {"if": {"column_id": "product"}, "textAlign": "left", "maxWidth": "120px", "minWidth": "100px", "overflow": "hidden", "textOverflow": "ellipsis"},
                        {"if": {"column_id": "incidents"}, "textAlign": "right", "maxWidth": "80px", "minWidth": "60px", 'fontVariantNumeric': 'tabular-nums'},
                        {"if": {"column_id": "downtime_minutes"}, "textAlign": "right", "maxWidth": "100px", "minWidth": "80px", 'fontVariantNumeric': 'tabular-nums'},
                        {"if": {"column_id": "availability_percentage"}, "textAlign": "right", "maxWidth": "100px", "minWidth": "80px", 'fontVariantNumeric': 'tabular-nums'},
                    ],
                    # Header sichtbar (nutzt Theme-Variablen)
                    style_header={'backgroundColor': 'var(--card-bg-color)', 'color': 'var(--text-color)', 'fontWeight': 'bold', 'border': '1px solid var(--border-color)'},
                    style_data_conditional=[
                        {
                            'if': {'state': 'active'},
                            'backgroundColor': 'var(--primary-color)',
                            'color': 'white',
                        },
                        {
                            'if': {'state': 'selected'},
                            'backgroundColor': 'var(--primary-color-light)',
                            'color': 'white',
                        }
                    ],
                    css=[
                        {
                            'selector': '.dash-table-container .dash-spreadsheet-container .dash-spreadsheet-inner table',
                            'rule': 'cursor: pointer;'
                        },
                        {
                            'selector': '.dash-table-container',
                            'rule': 'overflow-x: auto; -webkit-overflow-scrolling: touch;'
                        },
                        {
                            'selector': '.dash-table-container .dash-spreadsheet-container',
                            'rule': 'min-width: 600px;'
                        }
                    ],
                    tooltip_data=[
                        {
                            'organization': {'value': f"{r.get('name', '')} ‚Äî {r.get('organization', '')}", 'type': 'text'},
                            'name': {'value': f"{r.get('name', '')} ‚Äî {r.get('organization', '')}", 'type': 'text'},
                            'product': {'value': f"{r.get('name', '')} ‚Äî {r.get('organization', '')}", 'type': 'text'}
                        } for r in rows
                    ],
                    tooltip_duration=None

                ))([
                    {
                        'ci': entry['ci'],
                        'name': (
                            load_ci_metadata_map().get(str(entry.get('ci', '')), {}).get('name')
                            or entry.get('name', '')
                        ),
                        'organization': truncate_organization(
                            (
                                load_ci_metadata_map().get(str(entry.get('ci', '')), {}).get('organization')
                                or entry.get('organization', '')
                            )
                        ),
                        'product': (
                            load_ci_metadata_map().get(str(entry.get('ci', '')), {}).get('product')
                            or entry.get('product', '')
                        ),
                        'incidents': int(entry['incidents']),
                        'downtime_minutes': round(float(entry.get('downtime_minutes', 0.0))),
                        'availability_percentage': round(float(entry.get('availability_percentage', 0.0)), 2),
                    }
                    for entry in sorted(
                        overall_stats.get('top_unstable_cis_by_incidents', []),
                        key=lambda entry: (
                            float(entry.get('availability_percentage', 0.0)),
                            -int(entry['incidents'])
                        )
                    )
                ])
            ])
        ])
    ])

    return layout

layout = serve_layout

# Add a clientside callback for navigation
from dash import clientside_callback

clientside_callback(
    """
    function(active_cell, table_data) {
        if (active_cell && table_data) {
            const rowIndex = active_cell.row;
            if (rowIndex !== null && rowIndex < table_data.length) {
                const ci = table_data[rowIndex].ci;
                if (ci) {
                    window.location.href = '/plot?ci=' + ci;
                }
            }
        }
        return window.dash_clientside.no_update;
    }
    """,
    Output('stats-location', 'href'),
    [Input('unstable-cis-table', 'active_cell')],
    [State('unstable-cis-table', 'data')],
    prevent_initial_call=True
)
